package com.zakgof.db.velvet.dynamodb;

import java.io.ByteArrayInputStream;
import java.util.Collection;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.Callable;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import com.amazonaws.services.dynamodbv2.document.*;
import com.amazonaws.services.dynamodbv2.document.spec.GetItemSpec;
import com.amazonaws.services.dynamodbv2.document.spec.QuerySpec;
import com.amazonaws.services.dynamodbv2.document.spec.ScanSpec;
import com.amazonaws.services.dynamodbv2.model.*;
import com.google.common.primitives.Primitives;
import com.zakgof.db.velvet.IVelvet;
import com.zakgof.db.velvet.VelvetException;
import com.zakgof.db.velvet.query.IQueryAnchor;
import com.zakgof.db.velvet.query.IRangeQuery;
import com.zakgof.serialize.ISerializer;

public class DynamoDBVelvet implements IVelvet {

    private Supplier<ISerializer> serializerSupplier;
    private DynamoDB db;

    DynamoDBVelvet(DynamoDB db, Supplier<ISerializer> serializerSupplier) {
        this.db = db;
        this.serializerSupplier = serializerSupplier;
    }

    @Override
    public <K, V> IStore<K, V> store(String kind, Class<K> keyClass, Class<V> valueClass, Collection<IStoreIndexDef<?, V>> indexes) {
        return new Store<>(kind, keyClass, valueClass, indexes);
    }

    @Override
    public <K extends Comparable<? super K>, V> ISortedStore<K, V> sortedStore(String kind, Class<K> keyClass, Class<V> valueClass, Collection<IStoreIndexDef<?, V>> indexes) {
        return new SortedStore<>(kind, keyClass, valueClass, indexes);
    }

    @Override
    public <HK, CK> ILink<HK, CK> simpleIndex(HK key1, Class<HK> hostKeyClass, Class<CK> childKeyClass, String edgekind, LinkType type) {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public <HK, CK extends Comparable<? super CK>, T> IKeyIndexLink<HK, CK, CK> primaryKeyIndex(HK key1, Class<HK> hostKeyClass, Class<CK> childKeyClass, String edgekind) {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public <HK, CK, T, M extends Comparable<? super M>> IKeyIndexLink<HK, CK, M> secondaryKeyIndex(HK key1, Class<HK> hostKeyClass, String edgekind, Function<T, M> nodeMetric, Class<M> mclazz, Class<CK> keyClazz, IStore<CK, T> childStore) {
        // TODO Auto-generated method stub
        return null;
    }

    private class Store<K, V> implements IStore<K, V> {

        protected Class<K> keyClass;
        protected String kind;
        protected Class<V> valueClass;
        protected Table table;

        public Store(String kind, Class<K> keyClass, Class<V> valueClass, Collection<IStoreIndexDef<?, V>> indexes) {
            this.keyClass = keyClass;
            this.valueClass = valueClass;
            this.kind = kind;
            this.table = db.getTable(kind);
        }

        @Override
        public V get(K key) {
            Item item = calcOnTable(() -> getByKey(key));
            if (item == null) {
                return null;
            }
            V value = valueFromItem(item);
            return value;
        }

        @Override
        public byte[] getRaw(K key) {
            return null;
        }

        @Override
        public void put(K key, V value) {
            Object v = valueToObject(value);
            Item item = createPutItem(key, v);
            doOnTable(() -> table.putItem(item));
        }

        private V valueFromItem(Item item) {
            if (valueClass.equals(Long.class)) {
                return valueClass.cast(item.getLong("v"));
            } else if (valueClass.equals(Integer.class)) {
                return valueClass.cast(item.getInt("v"));
            } else if (valueClass.equals(Short.class)) {
                return valueClass.cast(item.getShort("v"));
            } else if (valueClass.equals(Byte.class)) {
                return valueClass.cast((byte)item.getShort("v"));
            }
            // TODO
            byte[] bytes = item.getBinary("v");
            V value = serializerSupplier.get().deserialize(new ByteArrayInputStream(bytes), valueClass);
            return value;
        }

        private Object valueToObject(V value) {
            if (Number.class.isAssignableFrom(Primitives.wrap(valueClass))) {
                return value;
            }
            byte[] bytes = serializerSupplier.get().serialize(value, valueClass);
            return bytes;
        }

        @Override
        public K put(V value) {
            if (!keyClass.equals(Long.class)) {
                throw new VelvetException("Autogenerated key must be Long");
            }
            // TODO: weak
            long id = UUID.randomUUID().getLeastSignificantBits();
            K key = keyClass.cast(id);

            put(key, value);
            return key;
        }

        @Override
        public void delete(K key) {
            table.deleteItem(keyFor(key));
        }

        @Override
        public List<K> keys() {
            ItemCollection<ScanOutcome> itemCollection = calcOnTable(() -> table.scan(new ScanSpec().withAttributesToGet("id")));
            List<K> keys = StreamSupport.stream(itemCollection.spliterator(), false).map(this::keyFromItem).collect(Collectors.toList());
            return keys;
        }

        @Override
        public boolean contains(K key) {
            Item item = table.getItem("id", key);
            return item != null;
        }

        @Override
        public long size() {
            // TODO
            return keys().size();
        }

        @Override
        public <M extends Comparable<? super M>> IStoreIndex<K, M> index(String name) {
            // TODO Auto-generated method stub
            return null;
        }

        protected void doOnTable(Runnable runnable) {
            try {
                runnable.run();
            } catch (ResourceNotFoundException e) {
                createTable();
                runnable.run();
            }
        }

        protected <T> T calcOnTable(Callable<T> callable) {
            try {
                try {
                    return callable.call();
                } catch (ResourceNotFoundException e) {
                    createTable();
                    return callable.call();
                }
            } catch (Exception e) {
                throw new VelvetException(e);
            }
        }

        protected Item getByKey(K key) {
            return table.getItem("id", key);
        }

        protected void createTable() {
            table = db.createTable(new CreateTableRequest()
               .withTableName(kind)
               .withKeySchema(new KeySchemaElement("id", KeyType.HASH))
               .withProvisionedThroughput(new ProvisionedThroughput(1L, 1L))
               .withAttributeDefinitions(new AttributeDefinition("id", keyType()))
            );
            try {
                table.waitForActive();
            } catch (InterruptedException e) {
                throw new VelvetException(e);
            }
        }

        protected Item createPutItem(K key, Object v) {
            return new Item().with("v", v).withKeyComponents(keyFor(key));
        }

        protected ScalarAttributeType keyType() {
            if (keyClass.equals(String.class))
                return ScalarAttributeType.S;
            else if (Number.class.isAssignableFrom(Primitives.wrap(keyClass)))
                return ScalarAttributeType.N;
            throw new VelvetException("Unsupported key class for dynamodb velvet: " + keyClass);
        }

        protected KeyAttribute[] keyFor(K key) {
            return new KeyAttribute[] {new KeyAttribute("id", key)};
        }

        protected K keyFromItem(Item item) {
            Class<K> kl = Primitives.wrap(keyClass);
            if (keyClass.equals(String.class)) {
                return kl.cast(item.get("id"));
            } else if (kl.equals(Long.class)) {
                return kl.cast(item.getLong("id"));
            } else if (kl.equals(Integer.class)) {
                return kl.cast(item.getInt("id"));
            } else if (kl.equals(Short.class)) {
                return kl.cast(item.getShort("id"));
            } else if (kl.equals(Byte.class)) {
                return kl.cast((byte) item.getShort("id"));
            }
            throw new VelvetException("Unsupported key class for dynamodb velvet: " + keyClass);
        }


    }

    private class SortedStore <K extends Comparable<? super K>, V> extends Store<K, V> implements ISortedStore<K, V> {

        public SortedStore(String kind, Class<K> keyClass, Class<V> valueClass, Collection<IStoreIndexDef<?, V>> indexes) {
            super(kind, keyClass, valueClass, indexes);
        }

        @Override
        public List<K> keys(IRangeQuery<K, K> query) {

            QuerySpec qs = new QuerySpec()
                .withAttributesToGet("id")
                .withHashKey("partition", 1);

            IQueryAnchor<K, K> lowAnchor = query.getLowAnchor();
            if (lowAnchor != null) {
                K k = lowAnchor.getKey() == null ? lowAnchor.getMetric() : lowAnchor.getKey();
                RangeKeyCondition condition = new RangeKeyCondition("id");
                condition = lowAnchor.isIncluding() ? condition.ge(k) : condition.gt(k);
                qs.withRangeKeyCondition(condition);
            }
            IQueryAnchor<K, K> highAnchor = query.getHighAnchor();
            if (highAnchor != null) {
                K k = highAnchor.getKey() == null ? highAnchor.getMetric() : highAnchor.getKey();
                RangeKeyCondition condition = new RangeKeyCondition("id");
                condition = highAnchor.isIncluding() ? condition.le(k) : condition.lt(k);
                qs.withRangeKeyCondition(condition);
            }
            if (query.getLimit() > 0) {
                int number = query.getLimit() + query.getOffset();
                qs.withMaxResultSize(number);
            }
            if (!query.isAscending()) {
                qs.withScanIndexForward(false);
            }

            List<K> keys = calcOnTable(() ->  {

                ItemCollection<QueryOutcome> itemCollection = table.query(qs);
                return StreamSupport.stream(itemCollection.spliterator(), false)
                    .skip(query.getOffset())
                    .map(this::keyFromItem)
                    .collect(Collectors.toList());

            });
            return keys;
        }

        @Override
        protected void createTable() {
            table = db.createTable(new CreateTableRequest()
               .withTableName(kind)
               .withKeySchema(new KeySchemaElement("partition", KeyType.HASH), new KeySchemaElement("id", KeyType.RANGE))
               .withProvisionedThroughput(new ProvisionedThroughput(1L, 1L))
               .withAttributeDefinitions(new AttributeDefinition("partition", ScalarAttributeType.N), new AttributeDefinition("id", keyType()))
            );
            try {
                table.waitForActive();
            } catch (InterruptedException e) {
                throw new VelvetException(e);
            }
        }

        @Override
        protected Item getByKey(K key) {
            return table.getItem(new GetItemSpec().withPrimaryKey(keyFor(key)));
        }

        @Override
        protected KeyAttribute[] keyFor(K key) {
            return new KeyAttribute[] {new KeyAttribute("partition", 1), new KeyAttribute("id", key)};
        }

        @Override
        protected Item createPutItem(K key, Object v) {
            return new Item()
               .with("v", v)
               .withKeyComponent("partition", 1)
               .withKeyComponent("id", key);
        }



    }



}
