package com.zakgof.db.velvet.datastore;

import java.io.ByteArrayInputStream;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import javax.xml.bind.DatatypeConverter;

import com.google.cloud.Timestamp;
import com.google.cloud.datastore.*;
import com.google.cloud.datastore.KeyQuery.Builder;
import com.google.cloud.datastore.StructuredQuery.CompositeFilter;
import com.google.cloud.datastore.StructuredQuery.OrderBy;
import com.google.cloud.datastore.StructuredQuery.PropertyFilter;
import com.google.common.primitives.Primitives;
import com.zakgof.db.velvet.IVelvet;
import com.zakgof.db.velvet.VelvetException;
import com.zakgof.db.velvet.query.IQueryAnchor;
import com.zakgof.db.velvet.query.IRangeQuery;
import com.zakgof.serialize.ISerializer;

public class DataStoreVelvet implements IVelvet {

    private Datastore datastore;
    private Supplier<ISerializer> serializerSupplier;

    DataStoreVelvet(Datastore datastore, Supplier<ISerializer> serializerSupplier) {
        this.datastore = datastore;
        this.serializerSupplier = serializerSupplier;
    }

    @Override
    public <K, V> IStore<K, V> store(String kind, Class<K> keyClass, Class<V> valueClass, Collection<IStoreIndexDef<?, V>> indexes) {
        return new Store<>(kind, keyClass, valueClass, indexes);
    }

    @Override
    public <K extends Comparable<? super K>, V> ISortedStore<K, V> sortedStore(String kind, Class<K> keyClass, Class<V> valueClass, Collection<IStoreIndexDef<?, V>> indexes) {
        return new SortedStore<>(kind, keyClass, valueClass, indexes);
    }

    @Override
    public <HK, CK> ILink<HK, CK> simpleIndex(HK key1, Class<HK> hostKeyClass, Class<CK> childKeyClass, String edgekind, LinkType type) {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public <HK, CK extends Comparable<? super CK>> IKeyIndexLink<HK, CK, CK> primaryKeyIndex(HK key1, Class<HK> hostKeyClass, Class<CK> childKeyClass, String edgekind) {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public <HK, CK, T, M extends Comparable<? super M>> IKeyIndexLink<HK, CK, M> secondaryKeyIndex(HK key1, Class<HK> hostKeyClass, String edgekind, Function<T, M> nodeMetric, Class<M> mclazz, Class<CK> keyClazz, IStore<CK, T> childStore) {
        // TODO Auto-generated method stub
        return null;
    }

    private class Store<K, V> implements IStore<K, V> {

        protected static final String SORTED_KEY_PROP = "___sorted_key_prop";
        protected Class<K> keyClass;
        private Class<V> valueClass;
        protected String kind;



        public Store(String kind, Class<K> keyClass, Class<V> valueClass, Collection<IStoreIndexDef<?, V>> indexes) {
            this.keyClass = keyClass;
            this.valueClass = valueClass;
            this.kind = kind;
        }

        @Override
        public V get(K key) {
            Key datastoreKey = datastoreKey(key);
            Entity entity = datastore.get(datastoreKey);
            if (entity == null) {
                return null;
            }
            Blob blob = entity.getBlob("v");
            V value = serializerSupplier.get().deserialize(blob.asInputStream(), valueClass);
            return value;
        }

        @Override
        public byte[] getRaw(K key) {
            return null;
        }

        @Override
        public void put(K key, V value) {
            Key datastoreKey = datastoreKey(key);
            byte[] valueBytes = serializerSupplier.get().serialize(value, valueClass);
            FullEntity.Builder<Key> builder = FullEntity.newBuilder(datastoreKey).set("v", Blob.copyFrom(valueBytes));
            FullEntity<Key> entity = decorate(key, builder).build();
            datastore.put(entity);
        }

        @Override
        public K put(V value) {
            if (!keyClass.equals(Long.class)) {
                throw new VelvetException("Autogenerated key must be Long");
            }
            byte[] valueBytes = serializerSupplier.get().serialize(value, valueClass);

            IncompleteKey incompleteKey = datastore.newKeyFactory().setKind(kind).newKey();
            Key datastoreKey = datastore.allocateId(incompleteKey);
            K key = keyClass.cast(datastoreKey.getId());

            FullEntity.Builder<Key> builder = FullEntity.newBuilder(datastoreKey).set("v", Blob.copyFrom(valueBytes));
            FullEntity<Key> entity = decorate(key, builder).build();
            datastore.put(entity);
            return key;
        }

        @Override
        public void delete(K key) {
            Key datastoreKey = datastoreKey(key);
            datastore.delete(datastoreKey);
        }

        @Override
        public List<K> keys() {
            Builder builder = Query.newKeyQueryBuilder().setKind(kind);
            Query<Key> query = decorateKeysQuery(builder).build();
            List<K> keys = fetchKeys(query);
            return keys;
        }

        protected Builder decorateKeysQuery(Builder builder) {
            return builder;
        }

        @Override
        public boolean contains(K key) {
            // TODO: check if query is faster or slower
            Key datastoreKey = datastoreKey(key);
            return datastore.get(datastoreKey) != null;
        }

        @Override
        public long size() {
            Query<Key> query = Query.newKeyQueryBuilder().setKind(kind).build();
            QueryResults<Key> results = datastore.run(query);
            int i=0;
            for(;results.hasNext(); i++) {
                results.next();
            }
            return i;
        }

        @Override
        public <M extends Comparable<? super M>> IStoreIndex<K, M> index(String name) {
            // TODO Auto-generated method stub
            return null;
        }

        protected <T extends IncompleteKey> FullEntity.Builder<T> decorate(K key, FullEntity.Builder<T> builder) {
            return builder;
        }

        protected List<K> fetchKeys(Query<Key> query) {
            QueryResults<Key> results = datastore.run(query);
            List<K> keys = StreamSupport.stream(Spliterators.spliteratorUnknownSize(results, Spliterator.ORDERED), false)
                .map(key -> keyFromDatastore(key))
                .collect(Collectors.toList());
            return keys;
        }

        private Key datastoreKey(K key) {
            Key datastoreKey = getLongKeyFor(key);
            if (datastoreKey == null) {
                String keyString = DatatypeConverter.printHexBinary(serializerSupplier.get().serialize(key, keyClass));
                datastoreKey = datastore.newKeyFactory().setKind(kind).newKey(keyString);
            }
            return datastoreKey;
        }

        protected Key getLongKeyFor(K key) {
            Long l = null;
            if (keyClass.equals(Long.class) || keyClass.equals(long.class)) {
                l = (Long)key;
            } else if (keyClass.equals(Integer.class) || keyClass.equals(int.class)) {
                l = (long)(Integer)key;
            } else if (keyClass.equals(Short.class) || keyClass.equals(short.class)) {
                l = (long)(Short)key;
            } else if (keyClass.equals(Byte.class) || keyClass.equals(byte.class)) {
                l = (long)(Byte)key;
            } else {
                return null;
            }
            if (l  == 0)
                return null;
            return datastore.newKeyFactory().setKind(kind).newKey(l);
        }

        private K keyFromDatastore(Key datastoreKey) {
            if (datastoreKey.getId() != null) {
                if (keyClass.equals(Long.class) || keyClass.equals(long.class)) {
                    return Primitives.wrap(keyClass).cast(datastoreKey.getId());
                } else if (keyClass.equals(Integer.class) || keyClass.equals(int.class)) {
                    return Primitives.wrap(keyClass).cast((int)(long)datastoreKey.getId());
                } else if (keyClass.equals(Short.class) || keyClass.equals(short.class)) {
                    return Primitives.wrap(keyClass).cast((short)(long)datastoreKey.getId());
                } else if (keyClass.equals(Byte.class) || keyClass.equals(byte.class)) {
                    return Primitives.wrap(keyClass).cast((byte)(long)datastoreKey.getId());
                }
                throw new VelvetException("Wrong key class " + keyClass + " for numeric datastore key " + datastoreKey);
//            } else if (keyClass.equals(String.class)) {
//                return keyClass.cast(datastoreKey.getName());
            } else {
                byte[] keyBytes = DatatypeConverter.parseHexBinary(datastoreKey.getName());
                K key = serializerSupplier.get().deserialize(new ByteArrayInputStream(keyBytes), keyClass);
                return key;
            }
        }

    }

    private class SortedStore <K extends Comparable<? super K>, V> extends Store<K, V> implements ISortedStore<K, V> {

        public SortedStore(String kind, Class<K> keyClass, Class<V> valueClass, Collection<IStoreIndexDef<?, V>> indexes) {
            super(kind, keyClass, valueClass, indexes);
        }

        @Override
        public List<K> keys(IRangeQuery<K, K> query) {
            Builder builder = Query.newKeyQueryBuilder().setKind(kind);
            List<PropertyFilter> filters = new ArrayList<>(2);

            IQueryAnchor<K, K> lowAnchor = query.getLowAnchor();
            if (lowAnchor != null) {
                Value<?> indexValue = indexValue(lowAnchor.getKey() == null ? lowAnchor.getMetric() : lowAnchor.getKey());
                filters.add(lowAnchor.isIncluding() ? PropertyFilter.ge(SORTED_KEY_PROP, indexValue) : PropertyFilter.gt(SORTED_KEY_PROP, indexValue));
            }
            IQueryAnchor<K, K> highAnchor = query.getHighAnchor();
            if (highAnchor != null) {
                Value<?> indexValue = indexValue(highAnchor.getKey() == null ? highAnchor.getMetric() : highAnchor.getKey());
                filters.add(highAnchor.isIncluding() ? PropertyFilter.le(SORTED_KEY_PROP, indexValue) : PropertyFilter.lt(SORTED_KEY_PROP, indexValue));
            }
            if (filters.size() == 1) {
                builder.setFilter(filters.get(0));
            } else if (filters.size() == 2) {
                builder.setFilter(CompositeFilter.and(filters.get(0), filters.get(1)));
            }

            if (query.getLimit() != -1) {
                builder.setLimit(query.getLimit());
            }
            if (query.getOffset() != 0) {
                builder.setOffset(query.getOffset());
            }
            builder.setOrderBy(query.isAscending() ? OrderBy.asc(SORTED_KEY_PROP) : OrderBy.desc(SORTED_KEY_PROP));
            KeyQuery keyQuery = builder.build();
            List<K> keys = fetchKeys(keyQuery);
            return keys;
        }

        @Override
        protected <T extends IncompleteKey> FullEntity.Builder<T> decorate(K key, FullEntity.Builder<T> builder) {
            return builder.set(SORTED_KEY_PROP, indexValue(key));
        }

        @Override
        protected Builder decorateKeysQuery(Builder builder) {
            return builder.addOrderBy(OrderBy.asc(SORTED_KEY_PROP));
        }

        private Value<?> indexValue(K key) {
            if (keyClass.equals(String.class)) {
                return StringValue.of((String)key);
            }

            if (keyClass.equals(Long.class) || keyClass.equals(long.class)) {
                return LongValue.of((Long)key);
            } else if (keyClass.equals(Integer.class) || keyClass.equals(int.class)) {
                return LongValue.of((Integer)key);
            } else if (keyClass.equals(Short.class) || keyClass.equals(short.class)) {
                return LongValue.of((Short)key);
            } else if (keyClass.equals(Byte.class) || keyClass.equals(byte.class)) {
                return LongValue.of((Byte)key);
            } if (keyClass.equals(Date.class)) {
                return TimestampValue.of(Timestamp.of((Date)key));
            } else if (keyClass.equals(LocalDateTime.class)) {
                Date date = Date.from(((LocalDateTime)key).atZone(ZoneId.systemDefault()).toInstant());
                return TimestampValue.of(Timestamp.of(date));
            } else if (keyClass.equals(LocalDate.class)) {
                Date date = Date.from(((LocalDate)key).atTime(0, 0).atZone(ZoneId.systemDefault()).toInstant());
                return TimestampValue.of(Timestamp.of(date));
            }
            throw new VelvetException("Unsupported key type for Sorted Store " + keyClass);
        }


    }



}
